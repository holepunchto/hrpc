module.exports = function generateCode (hyperInterface, { esm = false }) {
  let str = ''
  str += '// This file is autogenerated by the hyperinterface compiler\n'
  str += '/* eslint-disable camelcase */\n'
  str += '\n'

  if (esm) {
    str += 'import { c, RPC } from \'hyperinterface/runtime.mjs\'\n'
    str += 'import { getEncoding } from \'./messages.js\'\n'
  } else {
    str += 'const { c, RPC, RPCStream, RPCRequestStream } = require(\'hyperinterface/runtime.cjs\')\n'
    str += 'const { getEncoding } = require(\'./messages.js\')\n'
  }
  str += '\n'
  str += 'const methods = new Map([\n'
  hyperInterface.handlers.forEach((e, i) => {
    if (i < hyperInterface.handlers.length - 1) {
      str += `  ['${e.name}', ${i}],\n`
      str += `  [${i}, '${e.name}'],\n`
    } else {
      str += `  ['${e.name}', ${i}],\n`
      str += `  [${i}, '${e.name}']\n`
    }
  })
  str += '])\n'
  str += '\n'
  str += 'class HyperInterface {\n'
  str += '  constructor (stream) {\n'
  str += '    this._stream = stream\n'
  str += '    this._handlers = []\n'
  str += '    this._requestEncodings = new Map([\n'
  hyperInterface.handlers.forEach((e, i) => {
    if (i < hyperInterface.handlers.length - 1) {
      str += `      ['${e.name}', getEncoding('${e.request.name}')],\n`
    } else {
      str += `      ['${e.name}', getEncoding('${e.request.name}')]\n`
    }
  })
  str += '    ])\n'
  str += '    this._responseEncodings = new Map([\n'
  hyperInterface.handlers.forEach((e, i) => {
    if (i < hyperInterface.handlers.length - 1) {
      str += `      ['${e.name}', getEncoding('${e.response.name}')],\n`
    } else {
      str += `      ['${e.name}', getEncoding('${e.response.name}')]\n`
    }
  })
  str += '    ])\n'
  str += '    this._rpc = new RPC(stream, async (req) => {\n'
  str += '      const command = methods.get(req.command)\n'
  str += '      const responseEncoding = this._responseEncodings.get(command)\n'
  str += '      const requestEncoding = this._requestEncodings.get(command)\n'
  str += '      if (!this._requestIsStream(command) && !this._responseIsStream(command)) {\n'
  str += '        const request = c.decode(requestEncoding, req.data)\n'
  str += '        const response = await this._handlers[command](request)\n'
  str += '        req.reply(c.encode(responseEncoding, response))\n'
  str += '      }\n'
  str += '      if (!this._requestIsStream(command) && this._responseIsStream(command)) {\n'
  str += '        const request = c.decode(requestEncoding, req.data)\n'
  str += '        const responseStream = new RPCStream(null, null, req.createResponseStream(), responseEncoding)\n'
  str += '        responseStream.data = request\n'
  str += '        await this._handlers[command](responseStream)\n'
  str += '      }\n'
  str += '      if (this._requestIsStream(command) && !this._responseIsStream(command)) {\n'
  str += '        const requestStream = new RPCRequestStream(req, responseEncoding, req.createRequestStream(), requestEncoding)\n'
  str += '        const response = await this._handlers[command](requestStream)\n'
  str += '        req.reply(c.encode(responseEncoding, response))\n'
  str += '      }\n'
  str += '      if (this._requestIsStream(command) && this._responseIsStream(command)) {\n'
  str += '        const requestStream = new RPCRequestStream(req, responseEncoding, req.createRequestStream(), requestEncoding, req.createResponseStream(), responseEncoding)\n'
  str += '        await this._handlers[command](requestStream)\n'
  str += '  }\n'
  str += '    })\n'
  str += '  }\n'
  str += '\n'
  str += '  async _call (name, args) {\n'
  str += '    const requestEncoding = this._requestEncodings.get(name)\n'
  str += '    const responseEncoding = this._responseEncodings.get(name)\n'
  str += '    const request = this._rpc.request(methods.get(name))\n'
  str += '    const encoded = c.encode(requestEncoding, args)\n'
  str += '    request.send(encoded)\n'
  str += '    return c.decode(responseEncoding, await request.reply())\n'
  str += '  }\n'
  str += '\n'
  str += '  _callSync (name, args) {\n'
  str += '    const requestEncoding = this._requestEncodings.get(name)\n'
  str += '    const responseEncoding = this._responseEncodings.get(name)\n'
  str += '    const request = this._rpc.request(methods.get(name))\n'
  str += '    if (!this._requestIsStream(name) && this._responseIsStream(name)) {\n'
  str += '      const encoded = c.encode(requestEncoding, args)\n'
  str += '      request.send(encoded)\n'
  str += '      return new RPCStream(request.createResponseStream(), responseEncoding)\n'
  str += '    }\n'
  str += '    if (this._requestIsStream(name) && !this._responseIsStream(name)) {\n'
  str += '      return new RPCRequestStream(request, responseEncoding, null, null, request.createRequestStream(), requestEncoding)\n'
  str += '    }\n'
  str += '    if (this._requestIsStream(name) && this._responseIsStream(name)) {\n'
  str += '      return new RPCRequestStream(request, responseEncoding, request.createResponseStream(), responseEncoding, request.createRequestStream(), requestEncoding)\n'
  str += '    }\n'
  str += '  }\n'
  str += '\n'
  hyperInterface.handlers.forEach((e) => {
    const returnsStream = e.response.stream || e.request.stream
    str += `  ${returnsStream ? '' : 'async '}${convertToCamelCase(e.name)} (args) {\n`
    str += `    return this.${returnsStream ? '_callSync' : '_call'}('${e.name}', args)\n`
    str += '  }\n'
    str += '\n'
  })
  hyperInterface.handlers.forEach((e) => {
    str += `  ${convertToCamelCase(e.name, { prefix: 'on', isHandler: true })} (responseFn) {\n`
    str += `    this._handlers['${e.name}'] = responseFn\n`
    str += '  }\n'
    str += '\n'
  })
  str += '  _requestIsStream (command) {\n'
  str += '    return [\n'
  hyperInterface.handlers.filter(e => e.request.stream === true).forEach((e, i) => {
    if (i < hyperInterface.handlers.length - 1) {
      str += `      '${e.name}',\n`
    } else {
      str += `      '${e.name}'\n`
    }
  })
  str += '    ].includes(command)\n'
  str += '  }\n'
  str += '\n'
  str += '  _responseIsStream (command) {\n'
  str += '    return [\n'
  hyperInterface.handlers.filter(e => e.response.stream === true).forEach((e, i) => {
    if (i < hyperInterface.handlers.length - 1) {
      str += `      '${e.name}',\n`
    } else {
      str += `      '${e.name}'\n`
    }
  })
  str += '    ].includes(command)\n'
  str += '  }\n'
  str += '}\n\n'

  if (esm) {
    str += 'export default HyperInterface\n'
  } else {
    str += 'module.exports = HyperInterface\n'
  }

  return str
}

function convertToCamelCase (input, opts = { prefix: '', isHandler: false }) {
  if (input.startsWith('@')) {
    input = input.slice(1)
  }

  const parts = input.split(/[/-]/)

  const camelCased = parts.map((part, index) => {
    if (index === 0 && !opts.isHandler) return part
    return part.charAt(0).toUpperCase() + part.slice(1)
  })

  return opts.prefix + camelCased.join('')
}
